using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;

namespace AstGenerator;

[Generator]
public class AstGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Could split each file into individual lines, which might help the caching
        // But the generator should only be re-run if one of the .ast files are modified (new Expr or Stmt added), which should happen rarely enough for performance to not be a problem
        IncrementalValuesProvider<AdditionalText> text = context.AdditionalTextsProvider.Where(static file => file.Path.EndsWith(".ast"));
        IncrementalValuesProvider<(string name, string content)> namesAndContents = text.Select((text, cancellationToken) => (name: Path.GetFileNameWithoutExtension(text.Path), content: text.GetText(cancellationToken)!.ToString().Trim()));

        context.RegisterSourceOutput(namesAndContents, (spc, nameAndContent) =>
        {
            IEnumerable<string> lines = nameAndContent.content.Split('\n');
            string baseType = nameAndContent.name;

            spc.AddSource($"{baseType}.g.cs",
                $$"""
                // Autogenerated file. Modifications will be lost after the file is re-generated.
                #nullable enable

                namespace Generated;
                
                public abstract record {{baseType}}() 
                {
                    {{GetVisitor(lines, baseType)}}

                    {{GetVoidVisitor(lines, baseType)}}
                
                    {{GetTypeRecords(lines, baseType)}}

                    public abstract R Accept<R>(IVisitor<R> visitor);
                    public abstract void Accept(IVoidVisitor visitor);
                }
                """);
        });
    }

    /// <summary>
    /// Generate code for an interface (IVoidVisitor) that can be used to implement the visitor pattern.
    /// All visitor methods are void. 
    /// </summary>
    /// <param name="lines"></param>
    /// <param name="baseType"></param>
    /// <returns></returns>
    private string GetVoidVisitor(IEnumerable<string> lines, string baseType)
    {
        StringBuilder visitorBuilder = new();

        visitorBuilder.AppendLine("public interface IVoidVisitor\n\t{");

        foreach(string line in lines)
        {
            string typeName = line.Split(':')[0].Trim();
            visitorBuilder.AppendLine($"\t\tvoid Visit{typeName}{baseType}({typeName} {baseType.ToLowerInvariant()});");
        }

        visitorBuilder.AppendLine("\t}");

        return visitorBuilder.ToString();
    }

    private string GetVisitor(IEnumerable<string> lines, string baseType)
    {
        StringBuilder visitorBuilder = new();

        visitorBuilder.AppendLine("public interface IVisitor<R>\n\t{");

        foreach(string line in lines)
        {
            string typeName = line.Split(':')[0].Trim();
            visitorBuilder.AppendLine($"\t\tR Visit{typeName}{baseType}({typeName} {baseType.ToLowerInvariant()});");
        }

        visitorBuilder.AppendLine("\t}");

        return visitorBuilder.ToString();
    }

    private string GetTypeRecords(IEnumerable<string> lines, string baseType)
    {
        StringBuilder recordBuilder = new();

        foreach(string l in lines)
        {
            string[] typeAndProperties = l.Split(':').Select(s => s.Trim()).ToArray();

            Debug.Assert(typeAndProperties.Length == 2);

            string type = typeAndProperties[0];
            string properties = GetProperties(typeAndProperties[1]);

            recordBuilder.AppendLine(
                $$"""
                {{"\t"}}public record {{type}}({{properties}}) : {{baseType}} 
                {{"\t"}}{                    
                    {{"\t"}}public override R Accept<R>(IVisitor<R> visitor) 
                    {{"\t"}}{
                        {{"\t"}}return visitor.Visit{{type}}{{baseType}}(this);
                    {{"\t"}}}
                    
                    {{"\t"}}public override void Accept(IVoidVisitor visitor) 
                    {{"\t"}}{
                        {{"\t"}}visitor.Visit{{type}}{{baseType}}(this);
                    {{"\t"}}}
                {{"\t"}}}
                """);
        }

        string records = recordBuilder.ToString();
        return records.Trim();
    }

    private static string GetProperties(string properties)
    {
        string[] propertyTypesAndNames = properties.Split(',').Select(p => p.Trim()).ToArray();

        List<string> propTN = [];
        foreach(string propertyTypeAndName in propertyTypesAndNames)
        {
            string[] splitPropTypeAndName = propertyTypeAndName.Split(' ').Select(p => p.Trim()).ToArray();

            Debug.Assert(splitPropTypeAndName.Length == 2);

            propTN.Add($"{splitPropTypeAndName[0]} {splitPropTypeAndName[1][0].ToString().ToUpperInvariant() + splitPropTypeAndName[1].Substring(1)}");
        }

        return String.Join(", ", propTN);
    }
}