using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;

namespace AstGenerator;

[Generator]
public class AstGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Could split each file into individual lines, which might help the caching
        // But the generator should only be re-run if one of the .ast files are modified (new Expr or Stmt added), which should happen rarely enough for performance to not be a problem
        IncrementalValuesProvider<AdditionalText> text = context.AdditionalTextsProvider.Where(static file => file.Path.EndsWith(".ast"));
        IncrementalValuesProvider<(string name, string content)> namesAndContents = text.Select((text, cancellationToken) => (name: Path.GetFileNameWithoutExtension(text.Path), content: text.GetText(cancellationToken)!.ToString().Trim()));

        context.RegisterSourceOutput(namesAndContents, (spc, nameAndContent) =>
        {
            IEnumerable<string> nodes = nameAndContent.content.Split('\n');
            string baseType = nameAndContent.name;

            spc.AddSource($"{baseType}.g.cs",
                $$"""
                // Autogenerated file. Modifications will be lost after the file is re-generated.
                #nullable enable

                namespace Generated;
                
                public abstract record {{baseType}}() 
                {
                    {{GetVisitor(nodes, baseType, true, "IVisitor", "R")}}

                    {{GetVisitor(nodes, baseType, false, "IVoidVisitor", "void")}}
                
                    {{GetTypeRecords(nodes, baseType)}}

                    public abstract R Accept<R>(IVisitor<R> visitor);
                    public abstract void Accept(IVoidVisitor visitor);
                }
                """);
        });
    }

    /// <summary>
    /// Create a visitor interface.
    /// </summary>
    /// <param name="nodes">A string containing the name of the node and its fields in the format: "Name : Type propertyName"</param>
    /// <param name="baseType">The base type of the node (Expr or Stmt).</param>
    /// <param name="isGeneric">If true, the visitor interface will be generic. In this case, the parameter <paramref name="returnType"/> will be used as the generic type.</param>
    /// <param name="name">The name of the interface (e.g. IVisitor)</param>
    /// <param name="returnType">The return type of the visitor methods. If <paramref name="isGeneric"/> is true, this will also be used as the generic type.</param>
    /// <returns></returns>
    private string GetVisitor(IEnumerable<string> nodes, string baseType, bool isGeneric, string name, string returnType)
    {
        StringBuilder visitorBuilder = new();

        if(isGeneric)
        {
            visitorBuilder.AppendLine($"public interface {name}<{returnType}>\n\t{{");
        }
        else
        {
            visitorBuilder.AppendLine($"public interface {name}\n\t{{");
        }

        foreach(string node in nodes)
        {
            string typeName = node.Split(':')[0].Trim();
            visitorBuilder.AppendLine($"\t\t{returnType} Visit{typeName}{baseType}({typeName} {baseType.ToLowerInvariant()});");
        }

        visitorBuilder.AppendLine("\t}");

        return visitorBuilder.ToString();
    }

    private string GetTypeRecords(IEnumerable<string> lines, string baseType)
    {
        StringBuilder recordBuilder = new();

        foreach(string l in lines)
        {
            string[] typeAndProperties = l.Split(':').Select(s => s.Trim()).ToArray();

            Debug.Assert(typeAndProperties.Length == 2);

            string type = typeAndProperties[0];
            string properties = GetProperties(typeAndProperties[1]);

            recordBuilder.AppendLine(
                $$"""
                {{"\t"}}public record {{type}}({{properties}}) : {{baseType}} 
                {{"\t"}}{                    
                    {{"\t"}}public override R Accept<R>(IVisitor<R> visitor) 
                    {{"\t"}}{
                        {{"\t"}}return visitor.Visit{{type}}{{baseType}}(this);
                    {{"\t"}}}
                    
                    {{"\t"}}public override void Accept(IVoidVisitor visitor) 
                    {{"\t"}}{
                        {{"\t"}}visitor.Visit{{type}}{{baseType}}(this);
                    {{"\t"}}}
                {{"\t"}}}
                """);
        }

        string records = recordBuilder.ToString();
        return records.Trim();
    }

    private static string GetProperties(string properties)
    {
        string[] propertyTypesAndNames = properties.Split(',').Select(p => p.Trim()).ToArray();

        List<string> propTN = [];
        foreach(string propertyTypeAndName in propertyTypesAndNames)
        {
            string[] splitPropTypeAndName = propertyTypeAndName.Split(' ').Select(p => p.Trim()).ToArray();

            Debug.Assert(splitPropTypeAndName.Length == 2);

            propTN.Add($"{splitPropTypeAndName[0]} {splitPropTypeAndName[1][0].ToString().ToUpperInvariant() + splitPropTypeAndName[1].Substring(1)}");
        }

        return String.Join(", ", propTN);
    }
}